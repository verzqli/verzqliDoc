#### 题目：[n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)

> 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
>
> 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。
>

#### 示例

```java
输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
```

```java
输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
```



| 难度 | 初见 | 复习1次 | 复习2次 | 复习3次 | 复习4次 |
| :--: | :--: | :-----: | :-----: | :-----: | :-----: |
| 困难 |  ✖   |         |         |         |         |

#### 分析

这题说是简单，其实比中等还难一点。使用动态规划方法,也是动态规划的第三类问题。

用$dp[i][j]$表示第$i$个骰子总共投了$j$点的次数

状态转移方程：
$$
dp[i][j]=dp[i-1][j-m]m为个骰子投出的点数
$$
所以第i个骰子的点数

```java
for ( m= 1; m <= 6; m ++) {
    dp[i][j] += dp[i-1][j - m]
}
```

边界处理
这里的边界处理很简单，只要我们把可以直接知道的状态初始化就好了。

我们可以直接知道的状态是啥，就是第一阶段的状态：投掷完 11 枚骰子后，它的可能点数分别为 $1, 2, 3, ... , 6$并且每个点数出现的次数都是 1

```java
for (int i = 1; i <= 6; i ++) {
    dp[1][i] = 1;
}
```

然后判断从$[n,6n]$这些点数范围内的可能性，最后在根据当前点数的情况下，根据i-1个骰子产生的结果来得出当前i个骰子投出目前点数的次数

```java
 for (int i = 2; i <= n; i++) {
            for (int j = i; j <= 6 * i; j++) {
                for (int k = 1; k <=6 ; k++) {
                    //总点数一定要大于骰子数量
                    if (j-k<i-1){
                        break;
                    }
                    dp[i][j] += dp[i - 1][j - k];
                }
            }
        }
```

最终代码

```java
 public double[] twoSum(int n) {
        if (n <= 1) {
            return new double[]{1 / 6d, 1 / 6d, 1 / 6d, 1 / 6d, 1 / 6d, 1 / 6d};
        }
        double[] result = new double[5*n+1];
        int dp[][] = new int[n + 1][(6 * n) + 1];
        for (int i = 1; i <= 6; i++) {
            dp[1][i] = 1;
        }
        for (int i = 2; i <= n; i++) {
            for (int j = i; j <= 6 * i; j++) {
                for (int k = 1; k <=6 ; k++) {
                    //总点数一定要大于骰子数量
                    if (j-k<i-1){
                        break;
                    }
                    dp[i][j] += dp[i - 1][j - k];
                }
            }
        }
        double totalCount = Math.pow(6, n);
        for (int i = n; i <= 6 * n; i++) {
            result[i - n] =dp[n][i] / totalCount;
        }
        return  result;
    }
```





#### 复杂度

- 时间复杂度:$O(N^2)$
- 空间复杂度:$O(N^2)$

