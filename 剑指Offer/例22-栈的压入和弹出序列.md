#### 题目

> 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

#### 分析

这里两个序列指的是普通的数组，原来一直以为这两个也是栈，所以怎么想都没想明白

这里需要借助一个辅助栈，遍历压栈序列，先将第一个元素放在栈中，这里是1，然后判断栈顶元素是不是出栈序列的第一个元素，这里1≠4，所以继续压栈，直到相等之后开始出栈，出栈一个元素，对于出栈序列向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。

入栈1,2,3,4,5

出栈4,5,3,2,1

首先1入辅助栈，此时栈顶1≠4，继续入栈2

此时栈顶2≠4，继续入栈3

此时栈顶3≠4，继续入栈4

此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3

此时栈顶3≠5，继续入栈5

此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3

```java
 public boolean solve(int[] pushArray, int[] popArray) {
        Stack<Integer> temp = new Stack<>();
        int pushIndex = 0;
        int popIndex = 0;
        while (pushIndex < pushArray.length) {
   			 //遍历压入数据入栈            
            temp.push(pushArray[pushIndex]);
            //如果辅助栈不为空，且辅助栈顶等于出栈序列数据，就将这个辅助栈顶数据出栈，继续遍历第二个出栈序列数据。
            while (!temp.isEmpty() && (temp.peek() == popArray[popIndex])) {
                temp.pop();
                popIndex++;
            }
            pushIndex++;
        }
        return temp.isEmpty();
    }
```

