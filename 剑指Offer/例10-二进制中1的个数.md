- ###   and运算 &
    **按位与** 通常用于二进制的取位操作，转换为二进制后**相同位的两个数字都为1，则为1；若有一个不为1，则为0**。
```
0 0 1 0 1
1 1 1 0 0
---------
0 0 1 0 0
可以用来判断一个数的奇偶
只需要判断最后一个二进制位是 1 还是 0 就行了，如果是 1 的话，代表是奇数，如果是 0
if(n & 1 == 1){
    // n 是个奇数。
}
```
- ###  or运算 | 

    **按位或** 通常用于二进制的取位操作，转换为二进制后**相同位的两个数字只要有一个为1，那么就为1**。
```
0 0 1 0 1
1 1 1 0 0
---------
1 1 1 0 1
通常用于二进制特定位上的无条件赋值
例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，
对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。
if(n & 1 == 1){
    // n 是个奇数。
}  
```
- ###  xor运算 ^

    **按位异或** 通常用于二进制的取位操作，转换为二进制对每一位执行逻辑按位异或操作. 操作的结果是后**如果某位不同则该位为1, 否则该位为0.**。也即 **n ^ n = 0  n ^ 0 = n **
```
0 0 1 0 1
1 1 1 0 0
---------
1 1 0 0 1
```
^运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即（a ^ b) ^ b = a
```
例如a二进制为 1100101
b二进制为 00101
a^b
1 1 0 0 1 0 1
0 0 0 0 1 0 1
-------------
1 1 0 0 0 0 0
(a^b)^b
1 1 0 0 0 0 0
0 0 0 0 1 0 1
-------------
1 1 0 0 1 0 1
这种可以用于两数交换
x = x ^ y   // （1）
y = x ^ y   // （2）
x = x ^ y   // （3）
因为异或运算支持运算的交换律和结合律
y = x^y = (x^y)^y = x^(y^y) = x^0 = x
x = x^y = (x^y)^x = (x^x)^y = 0^y = y

```
来一道常见的算法题：给你一组整型数据，这些数据中，其中有一个数只出现了一次，其他的数都出现了两次，让你来找出一个数 。

正常用一个哈希表来存储，每次存储的时候，记录 某个数出现的次数即可

但是用位运算符^可知 n^n=0 n^0=n
```
1^2^3^4^5^1^2^3^4 = （1^1)^(2^2)^(3^3)^(4^4)^5= 0^0^0^0^5 = 5。

int find(int[] arr){
    int tmp = arr[0];
    for(int i = 1;i < arr.length; i++){
        tmp = tmp ^ arr[i];
    }
    return tmp;
}

```
- ###  not运算 ~
  **按位取反**运算的定义是把**内存中的0和1全部取反**。使用not运算时要格外小心，你需要注意整数类型有没有符号。如果not的对象是[无符号整数（不能表示负数）](https://baike.baidu.com/item/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0)，那么得到的值就是它与该类型上界的差，因为无符号类型的数是用00到$FFFF依次表示的。
```
8二进制为1 0 0 
~8则为 0 1 1  =5
```
- ###  左移右移 <<  >>
 **位移运算符**:a << b就是a转为二进制后左移b位,因为是二进制，所以**左移n位等于乘以2的n次方，右移则为除**
```
例如 11 二进制为 1 1 0 1
13 << 2为 1 1 0 1 0 0 = 32+16+4=52 = 13*2^2

```

### 位运算符算法

- #### 二进制数中1的个数

  ```java
   int count = 0;
   while (n > 0) {
   count++;
   n = (n - 1) & n;
   }
  ```

  一个数减去1后，你就会发现他从左到右第一个1会变成0，然后该1后面所有的0都会变成1

  例如：1100 减去1后就变成了1011 这时候把1011和原来的值1100做按位与运算就是1000，你会发现少了一个1，这是count计数加1，一直循环下去就可以算出二进制数中所有的1。



- #### 找出不大于N的最大的2的幂指数
```
代码解法
int findN(int N){
    int sum = 1;
   while(true){
        if(sum * 2 > N){
            return sum;
        }
        sum = sum * 2;
   }
}

```
位运算符号解法
N = 19，那么转换成二进制就是 00010011（这里为了方便，我采用8位的二进制来表示）。

那么我们要找的数就是，把二进制中最左边的 1 保留，后面的 1 全部变为 0。即我们的目标数是 00010000。那么如何获得这个数呢？

相应解法如下：
N = 19，那么转换成二进制就是 00010011（这里为了方便，我采用8位的二进制来表示）。那么我们要找的数就是，把二进制中最左边的 1 保留，后面的 1 全部变为 0。即我们的目标数是 00010000。那么如何获得这个数呢？相应解法如下：


1、找到最左边的 1，然后把它右边的所有 0 变成 1
 ```
 0 0 0 1 0 0 1 1
     转换
 0 0 0 1 1 1 1 1
 ```
 2、把得到的数值加 1，可以得到 00100000即 00011111 + 1 = 00100000。

 3、把 得到的 00100000 向右移动一位，即可得到 00010000，即 00100000 >> 1 = 00010000。

 通过把 n 右移并且做或运算即可得到。我解释下吧，我们假设最左边的 1 处于二进制位中的第 k 位(从左往右数),那么把 n 右移一位之后，那么得到的结果中第 k+1 位也必定为 1,然后把 n 与右移后的结果做或运算，那么得到的结果中第 k 和 第 k + 1 位必定是 1;同样的道理，再次把 n 右移两位，那么得到的结果中第 k+2和第 k+3 位必定是 1,然后再次做或运算，那么就能得到第 k, k+1, k+2, k+3 都是 1，如此往复下去....

 ```
 int findN(int n){
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8 ;// 这里直到8位范围，如果要更大就继续加。
    n |= n >> 16;
    return (n + 1) >> 1;
}

 ```