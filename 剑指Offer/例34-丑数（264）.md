#### 题目

> 编写一个程序，找出第 `n` 个丑数。
>
> 丑数就是质因数只包含 `2, 3, 5` 的**正整数**。
>
> 1. `1` 是丑数。
> 2. `n` **不超过**1690。

#### 示例

```java
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```

#### 分析

从上面不难发现丑数的规律， 如果n是丑数，那么2n，3n，5n都是丑数，这里可以用动态规划解决

用一个有序数组$dp$记录前$n$个丑数。三个指针$l2，l3和l5$指向$dp$中的元素，最小的丑数只可能出现在$dp[l2]$的2倍、$dp[l3]$的3倍和$dp[l5]$的5倍三者中间。通过移动三个指针，就能保证生成的丑数是有序的。

- 初始化数组dp和三个指针$l2、l3和l5$。$dp[0] = 1$，表示最小的丑数为1。三个指针都指向$dp[0]$。
- 重复以下步骤n次，dp[i]表示第i + 1小的丑数：
  - 比较2 * dp[l2], 3 * dp[l3], 5 * dp[l5]三者大小，令dp[i]为其中的最小值。
  - 如果dp[i] == 2 * dp[l2]，l2指针后移一位。
  - 如果dp[i] == 3 * dp[l3]，l3指针后移一位。
  - 如果dp[i] == 2 * dp[l5]，l5指针后移一位。

```java
 public int nthUglyNumber(int n) {
        int[] dp = new int[n];
        dp[0]=1;
        int l2=0,l3=0,l5=0;
        for (int i = 1; i < n; i++) {
            dp[i] = Math.min(Math.min(dp[l2]*2,dp[l3]*3),dp[l5]*5);
            if (dp[i]%2==0){
                l2++;
            }
            if (dp[i]%3==0){
                l3++;
            }
            if (dp[i]%5==0){
                l5++;
            }
        }
        return dp[n-1];
    }
```

