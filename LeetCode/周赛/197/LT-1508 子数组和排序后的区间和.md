#### 题目：[1508. 子数组和排序后的区间和](https://leetcode-cn.com/problems/range-sum-of-sorted-subarray-sums/)

> 给你一个数组 nums ，它包含 n 个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含 n * (n + 1) / 2 个数字的数组。
>
> 请你返回在新数组中下标为 left 到 right （下标从 1 开始）的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。
>

#### 示例

```java
输入：nums = [1,2,3,4], n = 4, left = 1, right = 5
输出：13 
解释：所有的子数组和为 1, 3, 6, 10, 2, 5, 9, 3, 7, 4 。将它们升序排序后，我们得到新的数组 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 1 到 ri = 5 的和为 1 + 2 + 3 + 3 + 4 = 13 。
```

```java
输入：nums = [1,2,3,4], n = 4, left = 3, right = 4
输出：6
解释：给定数组与示例 1 一样，所以新数组为 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 3 到 ri = 4 的和为 3 + 3 = 6 。

```



| 难度 | 初见 | 复习1次 | 复习2次 | 复习3次 | 复习4次 |
| :--: | :--: | :-----: | :-----: | :-----: | :-----: |
| 中等 |  ✖   |         |         |         |         |

#### 分析

求区间和的题目首先考虑的是前缀和相减 ，例如$[i,j]$区间的和为$S_j-S_{i-1}$

这里初始设置$S[i]$为0到i下标的前缀和，例子中[1,2,3,4]对应的就是[1,3,6,10].

设置$SS[i]$为0到i下标的前缀和的前缀和，也就是0到i的$S[i]$之和，例子中[1,2,3,4]对应的就是[1,4,10,20].作用后面会说。

我们可以发现题目要求[left,right]区间之和，假设全部枚举完且排好序了,令$K[i]$表示排好序之后的前i个区间和之和，那么答案就是$k[right]-k[left-1]$。这也就是暴力枚举解法。

通过上面我们知道得到答案需要求出排好序后[0,right]的所有的区间之和$F(right)$和$F(left-1)$,这里的方法就是通过二分法找和点，通过左右指针找区间数。

- 先找一个mid点（初始为所有区间和的一半），然后以这个mid值用双指针求出所有小于这个mid值的区间个数和这些区间的和。
- 如果区间和数量大于side边界值，说明我们所求的（0，side）的所有区间和的值再mid左边，所以r=mid，小于二分法同理
- 循环结束后我们获得了r值，这个值就是前side个区间的和。在减去重复计算的相等区间。
- get方法的作用是给定一个值mid，获取所有小于mid值的区间和个数和这些区间的总和。

get方法中获取区间和总和的证明：

区间[i,j]的所有总和为
$$
(S_{j}-S_{i})+(S_{j}-S_{i+1})+(S_{j}-S_{i+2})+...+(S_{j}-S_{j-1})
$$

$$
S_j*(j-i)-(S_{i}+S_{i+1}+S_{i+2}+...+S_{j-1})
$$

最开始我们设置了前缀和的前缀和数组SS；

所以这里就是：
$$
S_j*(j-i)-(SS[j-1]-SS[i-1])(i>0)
$$
这里最开始疑惑了好久的是为什么$(S_{j}-S_{i})+(S_{j}-S_{i+1})+(S_{j}-S_{i+2})+...+(S_{j}-S_{j-1})$这个方程式。

如例子[1,2,3,4]只计算[1,2,3,4],[2,3,4],[3,4]，为什么[1,2,3],[1,2]之类的没有计算。

后来明白了，因为这些区间前面都计算过了。

- i=0,j=1时，计算[1]

- i=0,j=2时，计算[2],[1,2]
- i=0,j=3时，计算[3],[2,3],[1,2,3]

- i=0,j=4时，计算[4],[3,4],[2,3,4],[1,2,3,4]

每次j多1，增加的区间就是前面的区间加上当前的值，再加上自身一个值作为区间，总共就是j个。

```java
 	public long[] s;
    public long[] ss;
    public int n = 0;

    public int rangeSum(int[] nums, int n, int left, int right) {
        this.n = n;
        s = new long[n + 1];
        ss = new long[n + 1];
        for (int i = 1; i <= n; i++) {
            s[i] = s[i - 1] + nums[i - 1];
            ss[i] = ss[i - 1] + s[i];
        }
        System.out.printf("F(right)"+F(right));
        return (int) ((F(right) - F(left - 1)) % 1000000007);
    }

    private long F(int side) {
        long l = 0;
        long r = ss[n];
        while (l < r) {
            long mid = (l + r) / 2;
            long[] t = get(mid);
            if (t[0] >= side) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        long[] res = get(r);
        //因为存在相同的区间和，所以这里用所有小于等于mid的区间和数量减去边界下标，就是相同的区间和个数
        return res[1] - (res[0] - side) * r;

    }

    long[] get(long mid) {
        //所有小于等于mid值的区间和的个数
        int count = 0;
        //所有小于等于mid值的区间和的和
        long sum = 0;
        for (int end = 1, start = 0; end <= n; end++) {
            while (s[end] - s[start] > mid) {
                start++;
            }
            if (start < end) {
                count += end - start;
                sum += s[end] * (end - start) - ss[end - 1];
                if (start != 0) {
                    sum += ss[start - 1];
                }
            }
        }
        return new long[]{count, sum};
    }
}

```



#### 复杂度

- 时间复杂度:$O(Nlog(Sum))，Sum为全数组元素之和$
- 空间复杂度:$O(N)$