#### 题目：[375. 猜数字大小 II](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/)

> 
> 我们正在玩一个猜数游戏，游戏规则如下：
>
> 我从 **1** 到 **n** 之间选择一个数字，你来猜我选了哪个数字。
>
> 每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。
>
> 然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。

#### 示例

```java
n = 10, 我选择了8.

第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。
第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。
第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。

游戏结束。8 就是我选的数字。

你最终要支付 5 + 7 + 9 = 21 块钱。

```

| 难度 | 初见 | 复习1次 | 复习2次 | 复习3次 | 复习4次 |
| :--: | :--: | :-----: | :-----: | :-----: | :-----: |
| 中等 |  ✖   |    ✖    |         |         |         |

#### 分析

 很难，这题并不是用常规的二分法，因为猜错是需要给钱的。

$dp[i][j]$表示从$[i,j]$中猜出正确数字所需要的最少花费金额.($dp[i][i] = 0$)假设在范围$[i,j]$中选择x, 则选择x的最少花费金额为:
$$
dp[i][j]=max(dp[i][x-1], dp[x+1][j]) + x
$$


**用max的原因是我们要计算最坏反馈情况下的最少花费金额(选了x之后, 正确数字落在花费更高的那侧)**

初始化为(n+2)数组的原因: 处理边界情况更加容易, 

例如对于求解$dp[1][n]$时x如果等于1, 需要考虑$dp[0][1]$(0不可能出现, $dp[0][n]$为0)

当x等于n时, 需要考虑$dp[n+1][n+1]$(n+1也不可能出现, $dp[n+1][n+1]$为0)

如何写出相应的代码更新dp矩阵, 递推式，x为当前猜的数
$$
dp[i][j] = (遍历x从i到j的最小值)min(max(dp[i][x-1], dp[x+1][j]) + x), x属于[i:j]
$$
可以画出矩阵图协助理解, 可以发现
$dp[i][x-1]$始终在$dp[i][j]$的左部, $dp[x+1][j]$始终在$dp[i][j]$的下部, 所以更新dp矩阵时i的次序应当遵循bottom到top的规则, j则相反, 由于
$i$肯定小于等于$j$, 所以我们只需要遍历更新矩阵的一半即可(下半矩阵)



|      |  1   |      2       |      3       |      4       |      5       |
| :--: | :--: | :----------: | :----------: | :----------: | :----------: |
|  1   |  0   | $dp[1][2]$=1 | $dp[1][3]$=2 | $dp[1][4]$=4 | $dp[1][5]$=6 |
|  2   |  --  |      0       | $dp[2][3]$=2 | $dp[2][4]$=3 | $dp[2][5]$=6 |
|  3   |  --  |      --      |      0       | $dp[3][4]$=3 | $dp[3][5]$=4 |
|  4   |  --  |      --      |      --      |      0       | $dp[4][5]$=4 |
|  5   |  --  |      --      |      --      |      --      |      0       |

```java
 public int getMoneyAmount(int n) {
        int dp[][] = new int[n + 2][n + 2];
        for (int start = n; start >= 1; start--) {
            for (int end = start; end <= n; end++) {
                if (start == end) {
                    //dp[start][end] = 0;
                    //默认为0，所以不用管start=end的情况
                    continue;
                } else {
                    //从[start,end]的范围内对每一个数做判断，当选择了这个数时，能够猜出所有点的最坏情况下（max）的最小值（min）
                    //就是[start,end]中的每一个数，选择了这个数作为判断点去猜数字后的所需要的最大花费，然后取这些最大化费的最小值
                    dp[start][end] = Integer.MAX_VALUE;
                    for (int k = start; k <= end; k++) {
                        dp[start][end] = Math.min(dp[start][end], Math.max(dp[start][k - 1], dp[k + 1][end]) + k);
                    }
                }
            }
        }
        return dp[1][n];
```




#### 复杂度

- 时间复杂度:$O(N^3)$
- 空间复杂度:$O(N^2)$