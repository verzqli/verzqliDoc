#### 题目

> 
> 最初在一个记事本上只有一个字符 'A'。你每次可以对这个记事本进行两种操作：
>
> 1. `Copy All` (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
> 2. `Paste` (粘贴) : 你可以粘贴你**上一次**复制的字符。
>
> 给定一个数字 `n` 。你需要使用最少的操作次数，在记事本中打印出**恰好** `n` 个 'A'。输出能够打印出 `n` 个 'A' 的最少操作次数。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/2-keys-keyboard
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 示例

```java
输入: 3
输出: 3
解释:
最初, 我们只有一个字符 'A'。
第 1 步, 我们使用 Copy All 操作。
第 2 步, 我们使用 Paste 操作来获得 'AA'。
第 3 步, 我们使用 Paste 操作来获得 'AAA'。
```

#### 分析

``dp[i]``表示，通过复制粘贴操作，得到 i 个字符，最少需要几步操作。

如果一个数是素数，那么最少操作就是一开始复制一个，最后一个个粘贴；

如果一个数不是素数，那么最少操作就可以按它的因数分解一下，简化操作。

举个例子，比如12，可以分解为 以下几种情况：

12 = 2*6, 需要操作``CPCPPPPP``总共8步

12 = 3*4, 需要操作``CPPCPPP``总共7步

12 = 4*3, 需要操作``CPPPCPP``总共7步

12 = 6*2, 需要操作``CPPPPPCP``总共8步

其实可以发现，因子相同的情况下，交换因子相乘的顺序，需要的步骤是一样的。所以我们可以简化一下分解的步骤，只需要找到小于sqrt(n)的因子即可。

假设找到的因子是 j ，那么需要的最小步骤就是 dp[j] + dp[i/j]，其中，dp[j]表示需要多少步生成这个因子，dp[i/j

```java
public int minSteps(int n) {
    int[] dp = new int[n + 1];
    int h = (int) Math.sqrt(n);
    for (int i = 2; i <= n; i++) {
        dp[i] = i;
        for (int j = 2; j <= h; j++) {
            if (i % j == 0) {
                dp[i] = dp[j] + dp[i / j];
                break;
            }
        }
    }
    return dp[n];
}
```

