#### 1题目

> 有 $N$ 个人围成一个圈，每$M$个人踢掉一个人，问最后留下来的人是几号？

#### 分析

这题衍生的题目有很多，例如猴子选大王，犹太人救自己一系列围圈踢人的题目。

这题如果用数组和循环链表来做时 时间复杂度是$O(MN)$,当$N$非常大时（$10^8$以上），就超时了。所以我们可以运用一点数学上的技巧，将最后结果推导出来。

首先把这$N$个人按序号$0，1，2，3...,N-2,N-1$进行排列，因为$M$是可能大于$N$也可能小于$N$。所以第一个出列的人的需要为$ (M-1) \% {N}$。

那么第一次出列的人的编号则是$ (M-1) \% {N}$，那么在第一个人出列之后，从他的下一个人又开始从0开始报数，为了方便我们设$k_1 = M\%N_1$（$N_1$为当前序列的总人数）那么在第一个人出列之后，$k_1$则是下一次新的编号序列的首位元素，那么我们得到的新的编号序列为：
$k_1，k_1+1，k_1+2，k_1+3...N-2，N-1，0，1，2...k_1-3，k_1-2 (k_1-1第一次已出列)$
那么在这个新的序列中，第一个人依旧是从0开始报数，那么在这个新的序列中，每个人报的相应数字为：
$0,1，2,3....N-2$
那么第二次每个人报的相应数字与第一次时自己相应的编号对应起来的关系则为：

$0 --> k_1$
$1 --> k_1+1$
$2 --> k_1+2$
...
$ N-2 --> (k_1+N-2)\%N_1(N_1为当前序列的总人数，因为是循环的序列，k_1+N-1可能大于总人数)$

那么这时我们要解决的问题就是N-1个人的报数问题（即N-1阶约瑟夫环的问题）

那么在这剩下的N-1个人中，我们也可以为了方便，将这N-1个人编号为：
$0,1,2,3,4...N-2$
那么此时出列的人的编号则是$(M-1) \% N_2$（$N_2$为当前序列的总人数），同样的我们设$K_2 = M \% N_2$，那么在这个人出列了以后，序列重排，重排后新的编号序列为：
$k_2，k_2+1，k_2+2，k_2+3...N-2，N-1，0，1，2...k_2-3，k_2-2$ ($k_2-1$第一次已出列)

后面的过程与前两次的过程一模一样，那么递归处理下去，直到最后只剩下一个人的时候，便可以直接得出结果

当我们得到一个人的时候（即一阶约瑟夫环问题）的结果，那么我们是否能通过一阶约瑟夫环问题的结果，推导出二阶约瑟夫环的结果呢？

假如得到了这个N-1阶约瑟夫环问题的结果为
$$
f(N-1)=aNs（即最后一个出列的人编号为aNs）
$$
那么我们通过上述分析过程，可以知道，N阶约瑟夫环的结果
$$
f(N)=(ans+ K)\%N(N为当前序列的总人数)
$$
而$K = M\%N$，所以N阶约瑟夫环的结果为
$$
f(N)=(ans+ M)\%N = (f(N-1) + M)\%N (N为当前序列的总人数)
$$


推导过程

当M<N时，易得上式可化简为：$（ans+ M）\% N$

而当M>=N时，那么上式则化简为：$（ans\% N + M\%N\%N）\% N$
即为：$（ans\% N + M\%N）\% N$
而 $（ans+ M）\% N = （ans\% N + M\%N）\% N$
因此得证
$(ans+ M \% N)\%N = （ans+ M）\% N$

举个例子：N=10,M=3如下表

|      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| N    | 7    | 8    |      | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| N-1  | 4    | 5    |      | 6    | 7    |      | 0    | 1    | 2    | 3    |
|      | 1    | 2    |      | 3    | 4    |      | 5    | 6    |      | 0    |

自我理解：假设最后一个被T的人下标为k，每次踢掉一人，在他们后面的所有人数字的下标都要减去3%10，那么前一轮他的下标为k+3%10（M/N）,因为这两者相加可能大于N,所以模上N.

所以结果为

```c
 int n, m, i, s = 0;
    printf ("N M = ");
    scanf("%d%d", &n, &m);
    for (i = 2; i <= n; i++)
    {
        s = (s + m) % i;
        printf("%d\n",s);
    }
    printf ("\nThe winner is %d\n", s+1);
```

这是$O(N)$时间复杂度，还有一种$O(logN)$的[算法](https://www.zhihu.com/question/358255792/answer/974983270)