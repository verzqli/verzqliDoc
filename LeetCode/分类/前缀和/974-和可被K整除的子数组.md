#### 题目：[974. 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/)

> 给定一个整数数组 `A`，返回其中元素之和可被 `K` 整除的（连续、非空）子数组的数目。

#### 示例

```java
输入：A = [4,5,0,-2,-3,1], K = 5
输出：7
解释：
有 7 个子数组满足其元素之和可被 K = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
```

| 难度 | 初见 | 复习1次 | 复习2次 | 复习3次 | 复习4次 |
| :--: | :--: | :-----: | :-----: | :-----: | :-----: |
| 困难 |  ✖   |         |         |         |         |

#### 分析

## 一看到“子数组和”，有必要马上想到“前缀和”

### √ 复习，什么是“前缀和”？

- 前面的所有，再包括自己（数组 第 0 项 到 当前项 的 总和）

- 如果用一个数组 preSum 表示：

- preSum[0]：数组A 第 0 项 到 第 0 项 的总和

- preSum[1]：数组A 第 0 项 到 第 1 项 的总和

- preSum[2]：数组A 第 0 项 到 第 2 项 的总和

- preSum[3]：数组A 第 0 项 到 第 3 项 的总和

  用方程表示就是
  $$
  preSum[i]  =A[0]+A[1]+...+A[i]
  $$
  于是数组的某一段，也就是子数组[i,j]
  $$
  A[i]+...+A[j] = preSum[j]-preSum[i-1]
  $$
  注意这里的i-1,i是可以为0的，此时i-1就成了-1，所以我们可以让preSum[-1]=0.此时
  $$
  A[0]+A[1]+...+A[j] = preSum[j]
  $$
  这么做是为了让边界情况也能套用通式（通式也能成立）

## 那么来看本题

- 子数组的元素之和，就是数组 第 i 项 到 第 j 项 的和

- 元素之和能被 K 整除的子数组数目 就是 有几种 i、j 组合，使得 第 i ~ j 项的和 mod K == 0

  ↓ ↓ ↓ **转化为** ↓ ↓ ↓

  存在$i,j$使得$(preSum[j]-preSum[i-1])modK==0$

  ↓ ↓ ↓ **转化为** ↓ ↓ ↓

  $preSum[j]mod K==preSum[i-1]mod K$

  这里需要注意一点，$preSum[j]和preSum[i-1]$都应该为正数

#### 求出 preSum 数组的每一项，然后呢？

- 因为我们不关心 前缀和 对应数组 A 的哪一项，即 **不关心具体位置**
- 只关心出现过哪些 **前缀和 % K** 的结果，和对应的 **出现次数**

- 所以可以使用一个hashmap，key为前缀和mod K的值，value为这个值出现了几次。
- 注意到， 前缀和 $mod K$ 的值正好是$ 0,1,2...,K-10,1,2...,*K*−1$，恰似索引，也可以用**数组**存，

#### 核心流程

- 预置边界情况 (即$ preSum[-1] = 0$ )：遍历数组 A 之前，map 提前放入 0:1，求第 0 项前缀和之前，前缀和 mod K 等于 0 已经出现 1 次
- 遍历数组 A 的每一项，求当前项的前缀和 $ mod K $ ，存入 map 中
  - 之前没有存过，则作为 key 存入，值为 1
  - 之前存过，则对应值 +1
- 边存边查看 map ，如果 map 中已存在 key 为 当前前缀和 mod K
  - 说明存在 之前求过的某个前缀和，它 $ mod K$  == 当前前缀和$  mod K$ 
  - 把满足条件的 key 对应的出现次数，累加给 count

#### 一句话总结

- 根据 当前前缀和 mod K，在 map 中寻找与之 相等 的 key 。满足条件的 历史前缀和 可能出现过 n 次。即，当前前缀和 找到 n 个历史前缀和，和它搭配而形成 n 个子数组，的元素和能被 K 整除。
- 遍历数组 A 每一项，重复以上步骤， n 不断累加给 count，最后返回 count

#### 注意点

代码中有``  int modulus = (sum % K + K) % K;``这一行

为什么取一次余后还要加K再取一次余，是为了判断sum为负数的情况。

例如[-2,5]和k=5，-2，7在map中分别存入的是(-2,1),（3，1）,如果取两次的结果是(3,1),(3,2)。

证明一个负数的余数和它加上K后的余数对后续不影响
$$
令(a+(-m))\%k = n
$$

$$
(a+(-m+k))\%k = a\%k+(-m+k)\%k = a\%k+(-m)\%k+k\%k=a\%k+(-m)k+0=(a+(-m))\%=n
$$

所以对一个负数取余后如果为负数，那么这个负数加上K是对后续计算结果没有影响的。

```java
  public int subarraysDivByK(int[] A, int K) {
        int count = 0;
        int sum = 0;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        for (int i = 0; i < A.length; i++) {
            sum += A[i];
            if (sum < 0) {
                //外面还要在%一次的例子：sum=-5
                sum = (sum % K + K) % K;
            } else {
                sum = sum % K;
            }
            int history = map.getOrDefault(sum, 0);
            count += history;
            map.put(sum, history + 1);
        }
        return count;
    }
```

#### 复杂度

- 时间复杂度:$O(N)$，遍历数组的长度N,只要需要从前到后遍历一次
- 空间复杂度:$O(min(N,K))$,当N<=K时，最多有N个前缀和，当N>K时，最多有K个不同的余数，所以哈希表需要的空间取决于N和K的较小值

