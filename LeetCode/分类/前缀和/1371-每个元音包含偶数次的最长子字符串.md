####      题目：[1371. 每个元音包含偶数次的最长子字符串](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/)

> 给你一个字符串 `s` ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。

#### 示例

```java
输入：s = "eleetminicoworoep"
输出：13
解释：最长子字符串是 "leetminicowor" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。
```

```java
输入：s = "leetcodeisgreat"
输出：5
解释：最长子字符串是 "leetc" ，其中包含 2 个 e 。
```

```java
输入：s = "bcbcbciawae"
输出：6
解释：注意这个例子，awa是长度为3，但是bcbcbc包含五个元音为0次，所以最长为6
```

| 难度 | 初见 | 复习1次 | 复习2次 | 复习3次 | 复习4次 |
| :--: | :--: | :-----: | :-----: | :-----: | :-----: |
| 中等 |  ✖   |         |         |         |         |

#### 分析

这题不好用语言去表达，详细看[题解](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/mei-ge-yuan-yin-bao-han-ou-shu-ci-de-zui-chang-z-2/)

用二进制来表示aeiou的奇偶变化，aeiou分别对应二进制00001，00010，00100，01000，10000，如果出现元音次数为偶数，该位就为0，如果是奇数就为1。

这样的奇偶情况有32中，所以创建一个32个长度的数组，遍历整个字符串，如果遍历到元音，就在该种状态值下标记录下字符下标，如果该状态值以前已经存储过值，说明以前出现过偶数次的该元音，计算出此时的最大长度，然后继续遍历

不过需要注意点，不存在任何元音字符的子字符串也符合都是偶数的设定（都为0），数组的初始值设为-1，方便计算。

举个例子 ``leetcodeo``

| 遍历字符 | 下标 | 是否元音 |  状态值   | 状态值存储的内容  | 最长长度 |
| :------: | :--: | :------: | :-------: | :---------------: | :------: |
|    l     |  0   |    否    |  00000=0  |   dp[0]=-1不变    |    0     |
|    e     |  1   |    是    |  00010=2  |     dp[2]=1+1     |    1     |
|    e     |  2   |    是    |  00000=0  |     dp[0]=2+1     |    3     |
|    t     |  3   |    否    |           |    dp[0]=3不变    |    4     |
|    c     |  4   |    否    |           |     dp[0]=4+1     |    5     |
|    o     |  5   |    是    | 00100 = 4 |    dp[4] = 5+1    |    5     |
|    d     |  6   |    否    |           |     dp[4]=6+1     |    5     |
|    e     |  7   |    是    | 00110=10  |    dp[10]=7+1     |    5     |
|    o     |  8   |    是    |  00010=2  | dp[2]=8-dp[2]+1=7 |    7     |

总而言之：

- 在遍历过程中出现第一个元音前，flag值都为0，出现元音前的长度都在flag上累加
- 当出现第一个元音时，flag值起变化，在该falg值存入字符下标，此时计算出该元音前的长度，保存为最大长度，
- 出现第一个元音后，后续不为元音的字符都在第一个元音上累加1，当出现两个元音时，flag重新归于一个以前出现过的值（是必然出现过的，这里是0）然后用此时字符下标减去前面出现过的长度得出新的最大长度，和前面的进行对比。
- 只有在数组[flag]存过数据的情况下才进行计算长度，其余的都情况下都是赋值累加。

```java
 public int findTheLongestSubstring(String s) {
        int n = s.length();
        int[] pos = new int[1 << 5];
        //全部存入-1，判断当前flag是否存进去了值
        Arrays.fill(pos, -1);
        int ans = 0, status = 0;
        pos[0] = 0;
        for (int i = 0; i < n; i++) {
            char ch = s.charAt(i);
            if (ch == 'a') {
                status ^= (1);
            } else if (ch == 'e') {
                status ^= (1 << 1);
            } else if (ch == 'i') {
                status ^= (1 << 2);
            } else if (ch == 'o') {
                status ^= (1 << 3);
            } else if (ch == 'u') {
                status ^= (1 << 4);
            }
            if (pos[status] >= 0) {
                ans = Math.max(ans, i + 1 - pos[status]);
            } else {
                pos[status] = i + 1;
            }
        }
        return ans;
    }
```





#### 复杂度

- 时间复杂度:$O(N)$ ,其中 n 为字符串 s 的长度。我们只需要遍历一遍字符串即可求得答案，因此时间复杂度为 O(n)。
- 空间复杂度:$O(N)$ 其中 S 表示元音字母压缩成一个状态数的最大值，在本题中 S = 32。我们需要对应 S大小的空间来存放每个状态第一次出现的位置，因此需要 O(S)的空间复杂度。

