#### 题目：[1014. 最佳观光组合](https://leetcode-cn.com/problems/best-sightseeing-pair/)

> 
> 给定正整数数组 `A`，`A[i]` 表示第 `i` 个观光景点的评分，并且两个景点 `i` 和 `j` 之间的距离为 `j - i`。
>
> 一对景点（`i < j`）组成的观光组合的得分为（`A[i] + A[j] + i - j`）：景点的评分之和**减去**它们两者之间的距离。
>
> 返回一对观光景点能取得的最高分。

#### 示例

```java
输入：[8,1,5,2,6]
输出：11
解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11
```

| 难度 | 初见 | 复习1次 | 复习2次 | 复习3次 | 复习4次 |
| :--: | :--: | :-----: | :-----: | :-----: | :-----: |
| 中等 |  ✖   |         |         |         |         |

#### 分析

这题需要把``A[i] + A[j] + i - j``分成``A[i]+i``和``A[j]-j``两步来算。

如果从左往右遍历，那么``A[j]-j``这个值是固定的，那么我们需要求的就是前``i``个数据里面``A[i]+i``的最大值

这其实就是动态规划，令dp[i]表示为前i个数字中``A[i]+i``的最大值，那么最佳观光组合就是dp[i]+``A[i]-i``

如果从右往左遍历，那么``A[i]Ii``这个值是固定的,我们需要求的是后``j``个数据里面``A[j]-j``的最大值

```java
 public int maxScoreSightseeingPair(int[] A) {
        int result = 0;
     	//这个其实就相当于是dp
        int maxI = A[0];
        for (int i = 1; i < A.length; i++) {
            result = Math.max(result, maxI + A[i] - i);
            maxI = Math.max(maxI, A[i] + i);
        }
        return result;
    }
```

#### 复杂度

- 时间复杂度:$O(N)$
- 空间复杂度:$O(1)$

