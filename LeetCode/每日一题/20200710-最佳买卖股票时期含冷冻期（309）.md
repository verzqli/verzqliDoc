#### 题目：[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

> 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。
>
> 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
>
> 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
> 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

#### 示例

```java
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

| 难度 | 初见 | 复习1次 | 复习2次 | 复习3次 | 复习4次 |
| :--: | :--: | :-----: | :-----: | :-----: | :-----: |
| 中等 |  ✖   |         |         |         |         |

#### 分析

这题想到了动态规划，也想到了根据前一个或者前两个来进行状态转移，可是还是没想出方程

我们用$dp[i] $表示第$ i $天结束之后的「累计最大收益」。根据题目描述，由于我们最多只能同时买入（持有）一支股票，并且卖出股票后有冷冻期的限制，因此我们会有三种不同的状态：

- 持有一支股票，对应的收益为$dp[i][0]$

- 不持有股票，且处在冷冻期，对应的最大收益为$dp][i][1]$
- 不持有股票，不处在冷冻期，对应的最大收益为$dp][i$][2]

下面进行状态转移，第$i$天时，我们可以进行买卖，此时第$i$天的状态会从第$i-1 $天的状态转移而来；当然我们今天也可以不做任何操作（可能当天股票价格很贵），此时第$i$天的状态就等同于第$i-1$天的状态，我们分别对这三种状态进行分析。

- 对于$dp[i][0]$:我们目前持有的这支股票可以在第$i-1$天就已经持有的，对应的状态为$dp[i-1][0]$；也可以是第$i$天买入的，那么低$i-1$天就不能持有股票且不再冷冻期中，对应的状态为$dp[i-1][2]$加上买入股票的负收益$-price[i]$，所以状态转移方程为：
  $$
  dp[i] = Math.max(dp[i-1][0],dp[i-1][2]-price[i])
  $$

- 对于$dp[i][1]$:我们在第$i$天结束后处于冷冻期是因为在当天卖出了股票，说明$i-1$天我们一定持有一支股票，对应的状态为$dp[i-1][0]$加上卖出股票的正收益$price[i]$,所以：
  $$
  dp[i][1] = dp[i-1][0]+price[i]
  $$

- 对于$dp[i][2]$:我们在第$i$天结束后既没有股票，也不出来冷冻期，那么可能是第$i-1$天可能是处于冷冻期或者第$i-1$天没有购买股票，因此：
  $$
  dp[i][2]  = Math.max(dp[i-1][1],dp[i-1][2])
  $$

所以最终的状态转移方程是以上三种。

注意到如果是最后一天结束后，手上如果还持有股票，那么是毫无意义且降低利润的，那么显然没有任何意义，所以最终答案应该是：
$$
result = Math.max(dp[len-1][1],dp[len-1][2])
$$
我们设置买入股票时是负收益，卖出股票时用$dp[i][0]$的值加上当前的价格就是利润，所以在开始时:
$$
dp[0][0] = -price[0]
$$
这样我们就可以从第 1 天开始，根据上面的状态转移方程进行进行动态规划，直到计算出第 n-1天的结果。

```java
  public int maxProfit(int[] prices) {
        int len = prices.length;
        int[][] dp = new int[len][3];
        dp[0][0] = -prices[0];
        // dp[i][0]: 手上持有股票的最大收益
        // dp[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益
        // dp[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益
        for (int i = 1; i <len ; i++) {
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][2]+(-prices[i]));
            dp[i][1] = dp[i-1][0]+prices[i];
            dp[i][2] = Math.max(dp[i-1][1],dp[i-1][2]);
        }
    return Math.max(dp[len-1][1],dp[len-1][2]);
    }
```

空间优化

```java
 int maxProfit(vector<int>& prices) {
        if (prices.empty()) {
            return 0;
        }

        int n = prices.size();
        int f0 = -prices[0];
        int f1 = 0;
        int f2 = 0;
        for (int i = 1; i < n; ++i) {
            int newf0 = max(f0, f2 - prices[i]);
            int newf1 = f0 + prices[i];
            int newf2 = max(f1, f2);
            f0 = newf0;
            f1 = newf1;
            f2 = newf2;
        }

        return max(f1, f2);
    }

```



#### 复杂度

- 时间复杂度:$O(N)$
- 空间复杂度:$O(1)$

