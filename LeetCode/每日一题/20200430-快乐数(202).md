#### 题目

> 编写一个算法来判断一个数 n 是不是快乐数。
>
> 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。
>
> 如果 n 是快乐数就返回 True ；不是，则返回 False 。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/happy-number
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 示例

```java
 

示例：

输入：19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

#### 分析

这题最重要的一个点是要认识到，无论多大的数字，要不最后等于1，要不就进行循环。看下表

| 1    | 最大值     | 平方和最大值 |
| ---- | ---------- | ------------ |
| 1    | 9          | 81           |
| 2    | 99         | 81*2=162     |
| 3    | 999        | 81*3=243     |
| ...  | ...        | ...          |
| 10   | 9999999999 | 81*10=810    |

通过上表发现没，3位数各位平方最大和为243，接着下去就肯定在243之下继续循环。而且从3位数往上，位数越高，计算后降位越严重，10位数计算后的结果成了810，810计算的结果肯定小于243。

所以一个数计算下去，要不等于1，要不就会遍历到最后无限循环，例如一个三位数他计算的值一定是小于243的，他最多循环的次数只有243，最后肯定会等于他前面出现的某一个数字

所以这题可以用``HashSet``记录下没个计算的值，当出现1或者HashSet中查到已经出现的数字时结束。

也可以用快慢指针：“快指针”每次走两步，“慢指针”每次走一步，当二者相等时，即为一个循环周期。此时，判断是不是因为1引起的循环，是的话就是快乐数，否则不是快乐数。

快慢指针是查找是否有相同点的好办法，查找链表是否有环也是用快慢指针。

```java
  public boolean isHappy(int n) {
        int fast = count(n);
        int slow = n;

        while (fast != 1 && fast != slow) {
            fast = count(count(fast));
            slow = count(slow);
        }
        return fast==1;
    }
    private int count(int n) {
        if (n < 10) {
            return n * n;
        }
        int result = 0;
        int i = 10;
        while (n > 0) {
            int d = n % 10;
            n = n / 10;
            result += d * d;
        }
        return result;

    }
```

