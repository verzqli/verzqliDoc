#### 题目：[面试题46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

> 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

#### 示例

```java
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```

| 难度 | 初见 | 复习1次 | 复习2次 | 复习3次 | 复习4次 |
| :--: | :--: | :-----: | :-----: | :-----: | :-----: |
| 中等 |  ✔   |         |         |         |         |

#### 分析

难得第一次思考做出了中等题。

这题想了一会考虑到每次加一个数字都要和前面的数字进行组合，所以自然想到了动态规划。

令$dp[i]$表示从左到右前$i$个数字的翻译方法数量。

$i$位这个数字可能出现两种情况，如这个例子$1,2,1,2,i$

- $i$和前一个数字（例子中的2）组合大于25,，也就是组合不了新的字符，例如$i=7$,因为$i$不能和前面数字组成新的字符，所以结果就是$dp[i-1]$的翻译结果加上这个$i$字符，也就是

$$
dp[i]=dp[i-1]
$$

- $i$和前一个数字（例子中的2）组合小于等于25，能够组合新的字符，例如$i=5$,这时候计算结果可以分两种情况

  - 把$i$看成是一个单独字符，让$dp[i-1]$的各种翻译方法后加上他这个字符，也就是有$dp[i-1]$种
  - 把$i-1$和$i$合并看成一个字符，让$dp[i-2]$的各种翻译方法后加上这个合并字符，这时候有$dp[i-2]$种情况

  综合起来就是
  $$
  dp[i]=dp[i-1]+dp[i-2]
  $$

为了方便理解，代码中将数字转化成了char数字，同时也没有用三个常量来替代dp数组，主要是为了更直观的了解原理，后续感兴趣的可以自己去优化一下

```java
   public int translateNum(int num) {
        if (num == 0) {
            return 1;
        }
        char[] array = String.valueOf(num).toCharArray();
        int[] dp = new int[array.length];
        //因为这里char下标是从0开始，所以dp[0]表示的是一个字符的时候
        dp[0] = 1;
        for (int i = 1, length = array.length; i < length; i++) {
            //当i字符能和i-1个字符能组成一个新的字符
            if ((array[i - 1] - '0' == 1) || ((array[i - 1] - '0' == 2) && (array[i] - '0' <= 5))) {
                if (i-2<0){
                    dp[i] = dp[i - 1] + dp[0];
                }else{
                    dp[i] = dp[i - 1] + dp[i-2];
                }
            }else{
                dp[i]=dp[i-1];
            }
        }
        return dp[array.length-1];
```



#### 复杂度

- 时间复杂度:$O(N)$
- 空间复杂度:$O(1)$