#### 题目

> 在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。
>
> 火车票有三种不同的销售方式：
>
> 一张为期一天的通行证售价为 costs[0] 美元；
> 一张为期七天的通行证售价为 costs[1] 美元；
> 一张为期三十天的通行证售价为 costs[2] 美元。
> 通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。
>
> 返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/minimum-cost-for-tickets
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 示例

```java
输入：days = [1,4,6,7,8,20], costs = [2,7,15]
输出：11
解释： 
例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：
在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。
在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。
在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。
你总共花了 $11，并完成了你计划的每一天旅行。
```

```java
输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
输出：17
解释：
例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 
在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。
在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 
你总共花了 $17，并完成了你计划的每一天旅行。
```

#### 分析

看到这题想到是用DP做，但还是找不到思路，[题解](https://leetcode-cn.com/problems/minimum-cost-for-tickets/solution/zui-di-piao-jie-by-leetcode-solution/)的递归略难懂，后面寻找到另一种较为易懂的[解法](https://leetcode-cn.com/problems/minimum-cost-for-tickets/solution/java-dong-tai-gui-hua-si-lu-bu-zou-cong-hou-xiang-/)。

通过买票我们可以判断后面多少天不需要买票，等价于今天买多少天的票，得看后面几天怎么安排，即``前面依赖后面``，所以从后向前来推断。

对于一个要出去旅行的日期``i``，我们有三种决策

- 决策1：买一天，也就是当天
- 决策2：买七天，也即``i``到``i+7-1``天花费一样
- 决策2：买三十天，也即``i``到``i+30-1``天花费一样，如果决策3中包含了决策2，那么决策2就无需花费

例如例子``[2,4,5,8,16]``

| day  | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16     | 17   | ...  |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ------ | ---- | ---- |
|      |      |      |      |      |      |      | ?    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | c[0]   | 0    | 0    |
|      |      |      |      |      |      |      | c[0] |      |      |      |      |      |      |      | c[0]   |      |      |
|      |      |      |      |      |      |      | c[1] | ✔    | ✔    | ✔    | ✔    | ✔    | ✔    |      | c[0]   |      |      |
|      |      |      |      |      |      |      | c[2] | ✔    | ✔    | ✔    | ✔    | ✔    | ✔    | ✔    | ✔（0） | ✔    | ✔    |

如上面表格，从后往前推，当为最后一个出行日期16时，很明显，不用想，最节省的开销就是买当天的，不存在决策2和3

轮到日期8时，就可以有三种决策了，买当天，买7天，买30天（卖了30天的，所以16天就无需在耗费金钱了）。

那么日期8时最节省的结果是什么？

```java
int result8 = min(c[0] + c[0], c[1] + c[0], c[2] + 0);
// 第 8 天  = min(决策1，      决策2,       决策3);
```

将上面的结果转化为递推公式

用dp[i]表示：从i天开始到最后的最少花费

```java
dp[i] = min(决策1, 决策2, 决策3);
      = min(c[0] + 1天后不包, c[1] + 7天后不包, c[2] + 30天不包);
      = min(c[0] + dp[i + 1], c[1] + dp[i + 7], c[2] + dp[i + 30]);
```

如下代码

```java
    public int mincostTickets(int[] days, int[] costs) {
        if (days.length == 1) {
            return costs[0];
        }
        int length = days.length ;
        int startDay = days[0];
        int endDay = days[length-1];
        int index = length-1;
        int[] dp = new int[endDay+30];
        for (int i = endDay; i >= startDay; i--) {
            if (i == days[index]) {
                dp[i] = Math.min(costs[0]+dp[i+1], costs[1] + dp[i + 7]);
                dp[i] = Math.min(dp[i], costs[2] + dp[i + 30]);
               index--;
            }else{
                //未出行的日子花费同后面的一致，不会增加
                dp[i]=dp[i+1];
            }

        }
        return dp[startDay];
    }
```

#### 复杂度分析

- 时间复杂度：O(endDay-startDay)
- 空间复杂度： O(N) ，用N+30的空间来存储dp
$$

$$

