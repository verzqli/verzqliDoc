#### 题目

> 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。

#### 示例

示例 1:

```
输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
```

示例 2:

```
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
```

#### 分析

记得这题以前做过一次，没写出来，这次自己想出了解法，一点小进步吧
从后向前遍历，倒数第二个点的当前下标和当前值相加大于最后一个值得下标，说明从倒数第二个点是可以跳转到最后一个点的

这时候把倒数第二个点当成最后点，往前遍历他前面一个点，如果可以就继续向前推，如果不可以则最后值不变，再向前推，直到第一个点。
遍历结束后如果保存的记录最后一个点的index还是等于nums.length - 1（初始设置点），那么说明前面这么多点根本没有点能跳过来，所以肯定为false。

如果第一个点的下标加值不能大于 我们设定浮动的最后一个点下标，那么肯定不可能成功

``` java
public boolean canJump(int[] nums) {
        if (nums.length <= 1) {
            return true;
        }
        if (nums[0] ==0) {
            return false;
        }
        int index = nums.length - 1;
        for (int i = nums.length - 2; i >= 0; i--) {
            if (i + nums[i] >= index) {
                index = i;
            } else {
                if (i == 0) {
                    return false;
                }
            }
        }
        return index != (nums.length - 1);
    }

```

上面是从后往前遍历，下面是从前往后遍历，代码更加简洁

如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点。
可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新。
如果可以一直跳到最后，就成功了。

```java
	int k = 0;
	for (int i = 0; i < nums.size(); i++)
	{
		if (i > k) return false;
		k = max(k, i + nums[i]);
	}
	return true;

```



作者：ikaruga
链接：https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

