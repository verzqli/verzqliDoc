#### 题目：[174. 地下城游戏](https://leetcode-cn.com/problems/dungeon-game/)

> 一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。
>
> 骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。
>
> 有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。
>
> 为了尽快到达公主，骑士决定每次只向右或向下移动一步。
>

#### 示例

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。

| -2（start） |  -3  |     3     |
| :---------: | :--: | :-------: |
|     -5      | -10  |     1     |
|     10      |  30  | -5（end） |

**说明:**

- 骑士的健康点数没有上限。
- 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。

| 难度 | 初见 | 复习1次 | 复习2次 | 复习3次 | 复习4次 |
| :--: | :--: | :-----: | :-----: | :-----: | :-----: |
| 困难 |  ✖   |         |         |         |         |

#### 分析

这题一开始想到了动态规划并且想到可能是从右下往左上递归，还是太嫩，没相出方程。

这题要从右下往左上的原因是因为终点的值会影响到前面路径的选择，前面的点所得到的最佳路径加上终点的值反而可能不是最佳的了。

用的$dp[i][j]$表示点$(i,j)$到终点所需的最小初始值。

因为只能向右或者想下，所以最右和最下两条边的值依次递加即可，注意的点是当值大于0是，置为0即可，因为我们求的是最小初始值，大于0多出来的生命值无意义。

第一步：先求出点$(i,j)$右边和下边的dp的最大值，这里用最大知道的原因是，前面我们设置了当dp中的值大于0时					就置为0，那么dp中的值要么等于0 ，要么小于0，而我们需要求的是最小初始值，所以选择消耗生命值较					小的那条路径

第二步：第一步比较出来的值加上当前的值（dungeon，不是dp），然后继续和0判断大小。大于0置为0，小于0填值

所以
$$
dp[i][j] = min(max(dp[i][j+1],dp[i+1][j])+dungeon[i][j],0)
$$
初始值为
$$
dp[row - 1][col - 1] = Math.min(dungeon[row - 1][col - 1], 0);
$$
最后最小初始值为
$$
dp[0][0]>0?1:-dp[0][0]+1
$$
因为最少要一点生命值，所以需要加上1.

```java
 public int calculateMinimumHP(int[][] dungeon) {
        int row = dungeon.length;
        int col = dungeon[0].length;
        int dp[][] = new int[row][col];
        dp[row - 1][col - 1] = Math.min(dungeon[row - 1][col - 1], 0);
        for (int i = col - 2; i >= 0; i--) {
            //通俗易懂的写法，可以转换成下面这row-2那种写法。
            int a = dungeon[row - 1][i] + dp[row - 1][i + 1];
            if (a > 0) {
                dp[row - 1][i] = 0;
            } else {
                dp[row - 1][i] = a;
            }
        }
        for (int i = row - 2; i >= 0; i--) {
            dp[i][col - 1] = Math.min(dungeon[i][col-1]+dp[i+1][col-1],0);
        }
        for (int i = row - 2; i >= 0; i--) {
            for (int j = col - 2; j >= 0; j--) {
                //这里最开始里面的max写成了min
                // 因为右边和下边的dp值要不为0，要不小于0，我们要求的最小生命值应该是取最大值
                dp[i][j] = Math.min(Math.max(dp[i][j + 1], dp[i + 1][j])+dungeon[i][j], 0);

            }
        }
        return  dp[0][0]>0?1:-dp[0][0]+1;
    }
```



#### 复杂度

- 时间复杂度:$O(M*N)$
- 空间复杂度:$O(M*N)$