#### 题目

> 给定一个整数数组和一个整数 **k，**你需要找到该数组中和为 **k** 的连续的子数组的个数。
>
> **说明 :**
>
> 1. 数组的长度为 [1, 20,000]。
> 2. 数组中元素的范围是 [-1000, 1000] ，且整数 **k** 的范围是 [-1e7, 1e7]。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/subarray-sum-equals-k
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 示例

```java
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```

#### 分析

首先注意这道题数组中是包含负数的，所以可能前两个和为K，前四个和也为K.

所以这题使用前缀和+hashmap的方式来解答。

- 维护一个 hashmap，hashmap 的 key 为累加值 temp，value 为累加值 temp出现的次数。
- 迭代数组，然后不断更新 temp，和 hashmap，如果 temp等于 k，那么很明显应该+1. 如果 hashmap[temp- k] 存在，我们就把它加到结果中去即可。


举个栗子[1,2,3,2,1,3,0,4,2] ,k=4

| 1    | 2    | 2    | 1    | 1    | 3    | 4    | 0    | 2    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 3    | 5    | 6    | 7    | 10   | 14   | 14   | 16   |

 第二行就是这个栗子的所有前缀和，然后把他们在map中的value值设为1。

然后在遍历过程中寻找前面是否存在map[当前前缀总和-k]的值来判断当前值是否可以构成一个和为K的子数组，

如上面栗子，遍历到下标为2的2时，此时map中存储了1，3的key，他们值为1，这时候加了2后生成了一个5的前缀和，5-k=1，然后查询到map中存在一个为1的前缀和，所以从1到5必然可以组成一个和为4的子数组。

而且如果这个1前缀和的map中value的值为2，那么表示前面出现了两次前缀和为1的情况，那么组成K的数组也可以变为两个。

```java
      public int subarraySum(int[] nums, int k) {
        Map<Integer,Integer> map = new HashMap<>();
        int count=0;
        int temp=0;
        for (int i = 0; i < nums.length; i++) {
            temp+=nums[i];
            //如果当前累加前缀值等于k，就加一
            if (temp==k){
                count++;
            }
            //例如temp=15，k为4,如果前面出现过11的前缀和，那么肯定存在和为K的数组，
            // 数量就等于前面出现前缀和为11的次数
            if (map.containsKey(temp-k)){
                count+=map.get(temp-k);
            }
            //如果map中不存在这个前缀和就加1，如果存在就加1
            map.put(temp,map.getOrDefault(temp,0)+1);

        }
        return count;
    }
```

