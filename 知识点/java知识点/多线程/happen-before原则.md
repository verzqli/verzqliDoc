## Happens-Before原则

> 如果Java内存模型中所有的有序性都仅仅靠``volatile`` 和``synchronized``来完成，那么有一些操作将会变得很烦琐，但是我们在编写Java并发代码的时候并没有感觉到这-一点， 这是因为Java语言中有一-个“先行发生”(happens before).的原则。这个原则非常重要，它是判断:数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。

Happens-Before原则：前面一个操作的结果对后续操作是可见的。
Happens-Before原则约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守Happens-Before原则。即使编译器进行指令重排序的优化，如果结果和重排序前一致，也是允许的。

 JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证（**如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见**）。

```java
i=1;//线程A中执行
j=i;//线程B执行
i=3;//线程C执行
```

假设线程A中先执行i=1操作，那么可以确定在线程B执行完j=i后，j一定等于1，得到答案的论据有两个：

- 根据happen-before原则，i=1的结果可被观察到
- 线程C还没有执行，在B之前，A之后没有其他线程修改了i的值

如果线程C在A和B之间，但是C和B之间没有先行关系，那么j既可能是 1，也可能是2，因为B对i的修改可能被C观察到，也可能观查不到，这时候B就有读到过期数据的风险。

**具体的定义为：**

- 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
- 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。】

下面是Java内存模型下一-些“天然的"先行发生关系，这些先行发生关系无须任何同步三器协助就已经存在，可以在编码中直接使用，如果两个操作之间的关系不在此列，并且无法从下 列规则推导川来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。

- **程序次序规则(Program Order Rule) :**在一个线程内:,按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。

- **口管程锁定规则( Monitor Lock Rule )：**一个unlock操作先行发生于后面对间二个锁的 loc操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。

- **volatile变量规则. (Volaile Variable; Rule):**对一个volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的“后面"同样是指时间上的先后顺序。”了
- **线程启动规则(Thread Slart Rule) ; **Thread对象的start()方法先行发生于此线程的每一个动作。
- **线程终止规则(Thread Teimination Rule)：**线程中的所有操作都先行发生于对此线程的终止检测.我们可以通过Thread.join()方法结束，Thead.islive()的返回值等手段检测到线程已经终止执行。
- **线程中断规则(Thread interruptionRuler):**对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread. interrupted()方法检测到步是否有中断发生。
- **对象终结规则(Finalizer Rule):**一个对象的初始化完成(构造函数执行结束)先行发生于它的fnalize()方法的开始
- **传递性:( Tansitivity):**如果操作A先行发生于B操作,B先行发生于操作C,那就可以得出操作A先行发生于操作C的结论。

如下例子：

```java
private int value = 0;

pubile void setValue (int value) {
	this.value =value; 
}
public int getvalue() {
	return value;
}
```

这里假设A先调用setValue（1），然后线程B调用getValue,那么返回值是多少？

因为这里是两个线程，所以第一条不适用，没有添加锁和volatile，所以第二第三条也不适用，后面线程的启动中断和终止也没关系，对象终结也没关系，所以最后的传递性就无从谈起。

所以最后B线程观察到的value可能是1也可能是0.上面例子可以通过volatile修饰value或者给方法加syhchronize的方式来达到观测正确的目的。

通过上面的例子，我们可以得出结论: -一个操作“时间上的先发生”不代表这个操作会是“先行发生”，那如果一个操作“ 先行发生”是否就能推导出这个操作必定是“时间上的先发生”呢?很遗憾，这个推论也是不成立的，-个典型的例子就是多次提到的“ 指令重排序”，演示例子如代码清单12-10 所示。

```java
int i=1;
int j=2;
```

上面两行代码发生在同一个线程中，1在顺序上先于2，但是代码2的操作完全可能先被处理器执行，但是这并不影响结果的正确性。

上面两个例子综合起来证明了一个结论:**时间先后顺序与先行发生原则之间基本没有太大的关系**，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。