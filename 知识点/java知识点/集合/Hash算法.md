https://www.hollischuang.com/archives/2091



## Hash算法

> **Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。**

所有散列函数都有如下一个基本特性：**根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。**

**两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。**

#### hash函数

- 直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。

- 数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。

- 除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。

- 分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。

- 平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。

- 伪随机数法：采用一个伪随机数当作哈希函数。

#### hash碰撞解决

上面介绍过碰撞。衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。任何哈希函数基本都无法彻底避免碰撞，常见的解决碰撞的方法有以下几种：

- ``开放定址法``：开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。
- ``链地址法``:将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。
- ``再哈希法``:当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。
- ``建立公共溢出区``:将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。

### Hash

hash方法的功能是根据Key来定位这个K-V在链表数组中的位置的。也就是hash方法的输入应该是个Object类型的Key，输出应该是个int类型的数组下标.

调用``Object``对象的``hashCode()``方法，该方法会返回一个整数，然后用这个数对``HashMap``或者``HashTable``的容量（也就是Bucket，这里是决定把这个数据放在哪个桶中）进行取模就行了。

#### HashMap

```java
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
//取模
 if ((p = tab[i = (n - 1) & hash]) == null)
```

``JDK8``中``indexFor``没有了，直接将代码``i = (n - 1) & hash``放在了数组中运算

​		那么这行代码是什么意思呢，就是取模。这里的n就是桶的数量，取模后的数表示该放在哪个桶中。这里通过位运算直接计算出答案，比转换成十进制后效率更高，原理如下。

​		首先，因为HashMap中初始容量为16 ，每次扩容都是将容量翻倍，所以它的容量是$2^n$。

​		当一个数除以$X=2^n$ 等价于这个数向右移动N位。那么被移走的那末尾N位就是除以这个X的余数。同时X-1在二进制中把N位变为0，后面全部变为1，所以用除以X的余数和全是1的数量进行$\&$按位与运算就得到了取模的值。

```java
X % 2^n = X & (2^n – 1)

2^n表示2的n次方，也就是说，一个数对2^n取模 == 一个数和(2^n – 1)做按位与运算 。

假设n为3，则2^3 = 8，表示成2进制就是1000。2^3 -1 = 7 ，即0111。

此时X & (2^3 – 1) 就相当于取X的2进制的最后三位数。

从2进制角度来看，X / 8相当于 X >> 3，即把X右移3位，此时得到了X / 8的商，而被移掉的部分(后三位)，
 则是X % 8，也就是余数。& (2^n – 1)这个位运算的功能就是确定余数是后几位并把他们提取出来。
```

所以这也正是``HashMap``容量要为2的次幂的原因。

​		``HashMap``的数据是存储在链表数组里面的。在对``HashMap``进行插入/删除等操作时，都需要根据K-V对的键值定位到他应该保存在数组的哪个下标中。而这个通过键值求取下标的操作就叫做哈希。

​		``HashMap``的数组是有长度的，Java中规定这个长度只能是2的倍数，初始值为16。简单的做法是先求取出键值的``hashcode``，然后在将``hashcode``得到的int值对数组长度进行取模。为了考虑性能，Java总采用按位与操作实现取模操作。

##### hash方法

​		接下来我们会发现，无论是用取模运算还是位运算都无法直接解决冲突较大的问题。比如：`CA11 0000`和`0001 0000`在对`0000 1111`进行按位与运算后的值是相等的。

​	两个不同的键值，在对数组长度进行按位与运算后得到的结果相同，这不就发生了冲突吗。那么如何解决这种冲突呢，关于Java 8中的hash函数，原理和Java 7中基本类似。Java 8中这一步做了优化，只做一次16位右位移异或混合，而不是四次，但原理是不变的。。

```java
//Java7
static final int hash(Object key) {
    h ^= k.hashCode();
    h ^= (h >>> 20) ^ (h >>> 12);
return h ^ (h >>> 7) ^ (h >>> 4);
}
static int indexFor(int h, int length) {
    return h & (length-1);
}
//Java8
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
int index = i = (n - 1) & hash;
```

hash方法作用主要是为了对key的hashCode进行扰动计算，防止不同hashCode的高位不同但低位相同导致的hash冲突。简单点说，就是为了把高位的特征和低位的特征组合起来，降低哈希冲突的概率。**尽量做到任何一位的变化都能对最终得到的结果产生影响。**

这里Java8稍微优化了一下，只把高位16和低位16进行一次位运算。

这样运算还有一个好处就是解决负数的问题，int的第一位0表示正数，1表示负数，而我们要获得的桶数组下标一定是整数，所以移位后两个数按位与运算后，第一位一定是个0，得到的数就一定是正数。

### HashTable

```java
//Java7
private int hash(Object k) {
    // hashSeed will be zero if alternative hashing is disabled.
    return hashSeed ^ k.hashCode();
}
int index = (hash & 0x7FFFFFFF) % tab.length;

//Java8
int hash = key.hashCode();
int index = (hash & 0x7FFFFFFF) % tab.length;
```

``HashTable``只是对k做了一个简单的hash，获得inedx的值``(hash & 0x7FFFFFFF) % tab.length``中与``0x7FFFFFFF``做一次按位与是为了得到一个正数（``0x7FFFFFFF``=011...1），通过按位与可以保证首位为1，后面位的值不变吗，最后通过$\%$运算来得到``index``吗，在Java8中就直接去掉了hash方法，直接用``key.hashCode()``

那么为什么HashTable不用Hashmap那样的位运算而是直接模运算呢？

##### 扩容手法

HashTable默认的初始容量为11.之后每次扩容为原来的2N+1；

也就是说，HashTable的链表数组的默认大小是一个素数、奇数。之后的每次扩充结果也都是奇数。

由于HashTable会尽量使用素数、奇数作为容量的大小。当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀。（这个是可以证明出来的，可参考：http://zhaox.github.io/algorithm/2015/06/29/hash）

至此，我们看完了Java 中``HashMap``和``HashTable``中对于hash的实现，我们来做个简单的总结。

- ``HashMap``默认的初始化大小为16，之后每次扩充为原来的2倍。
- ``HashTable``默认的初始大小为11，之后每次扩充为原来的2n+1。
- 当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀，所以单从这一点上看，``HashTable``的哈希表大小选择，似乎更高明些。因为hash结果越分散效果越好。
- 在取模计算时，如果模数是2的幂，那么我们可以直接使用位运算来得到结果，效率要大大高于做除法。所以从hash计算的效率上，又是``HashMap``更胜一筹。
- 但是，``HashMap``为了提高效率使用位运算代替哈希，这又引入了哈希分布不均匀的问题，所以``HashMap``为解决这问题，又对``hash``算法做了一些改进，进行了扰动计算。

### ConcurrentHashMap

这是一个保持线程安全的HashMap

```java
//	Java7
private int hash(Object k) {
    int h = hashSeed;

    if ((0 != h) && (k instanceof String)) {
        return sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();

    // Spread bits to regularize both segment and index locations,
    // using variant of single-word Wang/Jenkins hash.
    // 这里主要目的和HashMap中的一致，都是为了让高低位组合，降低碰撞概率
    h += (h <<  15) ^ 0xffffcd7d;
    h ^= (h >>> 10);
    h += (h <<   3);
    h ^= (h >>>  6);
    h += (h <<   2) + (h << 14);
    return h ^ (h >>> 16);
}

int j = (hash >>> segmentShift) & segmentMask;
//	Java8
// HASH_BITS = 0x7fffffff;原理一致，保证为正数
/**
 * 将散列的较高位散布（XOR）较低，也将最高位强制为0。
 * 由于该表使用2的幂次掩码，仅在当前掩码上方的位中变化的哈希集将始终发生冲突。
 * （众所周知的示例是在小表中包含连续整数的Float键集。）
 * 因此，我们应用了一种将向下扩展较高位的影响的变换。 在速度，实用性和位扩展质量之间需要权衡。
 * 由于许多常见的哈希集已经合理分布（因此无法从扩展中受益），
 * 并且由于我们使用树来处理容器中的大量冲突集，因此我们仅以最便宜的方式对一些移位后的位进行XOR，
 * 以减少系统损失， 以及合并最高位的影响，否则由于表范围的限制，
 * 这些位将永远不会在索引计算中使用。
 */
static final int spread(int h) {
    return (h ^ (h >>> 16)) & HASH_BITS;
}
index = (n - 1) & key.hashCode())
```

Java7中ConcurrentHashMap的hash实现其实和HashMap如出一辙。都是通过位运算代替取模，然后再对hashcode进行扰动。

Java 8 里面的求hash的方法从hash改为了spread。获得index的方式还是和HashMap一样。

Java 8的ConcurrentHashMap同样是通过Key的哈希值与数组长度取模确定该Key在数组中的索引。同样为了避免不太好的Key的hashCode设计，它通过如下方法计算得到Key的最终哈希值。

不同的是，Java 8的ConcurrentHashMap作者认为引入红黑树后，即使哈希冲突比较严重，寻址效率也足够高，所以作者并未在哈希值的计算上做过多设计，只是将Key的hashCode值与其高16位作异或并保证最高位为0（从而保证最终结果为正整数）。

